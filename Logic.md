#Logic of code:
##search:
We write a helper function called tree_search(), this function helps us to find the LeafNode that contains the key that we need to search. In this helper function, we use recursion to traverse the tree from the root, and return the child node contains the search key of the input node. After return the LeafNode to the function search(), we traverse all the keys of this LeafNode, if it contains the search key, return the value of this key, else return null.

##insert: 
If we insert a null key, just return and do nothing to the tree.
Then we decide whether the root is null, if the root is null, means this tree is empty and we need to initiate a new LeafNode to be root and store the key and value into this root. If the root is not null, we need to do insert in a recursion way. We write a helper function called tree_insert(), and in this function, we traverse the tree from the root recursively and find the LeafNode that we need to insert key and value. This function return null if there is no overflow happened, and if overflow happened, call function splitIndexNode()/splitLeafNode() to handle the overflow, and return a entry contains the new key and new node that to be insert into it's parent node. Finally, return back to the function insert(), if return null, then finish insert, otherwise let the root becomes IndexNode and set it's two children LeafNodes.

##delete:
If we delete a null key, just return and do nothing to the tree.
Then if the root is LeafNode and contains the key, delete the key and value from it. Otherwise find the child node of the root and call the helper function tree_delete(). In this function, we traverse the tree from the root recursively and find the LeafNode that we need to delete the key and value. If the target node contains the key, delete it and it's corresponding value. Then we need to decide whether this node is underflow. If it is not underflow, return -1. If it is underflow we call function handleLeafNodeUnderflow()/handleIndexNodeUnderflow(). If target node's sibling has extra entries, then redistribute this two nodes and change the value of their parent node, then return -1. Otherwise we do merging and delete the corresponding key from the parent node. Finally return back to the function delete() and redistribute the root according to the return result.
